import meta.state.PlayState;
import gameObjects.character.AtlasCharacter;
import graphics.FunkinSprite;
import flxanimate.FlxAnimate;
import flixel.FlxG;
import meta.modding.base.ScriptedFlxSpriteGroup;

class Nene extends AtlasCharacter 
{
    //DO NOT THINK NENE FROM HOLOLIVE
    //DO NOT THINK NENE FROM HOLOLIVE
    //DO NOT THINK NENE FROM HOLOLIVE
    //DO NOT THINK NENE FROM HOLOLIVE
    function new() {
		super('nene');
	}
    
    var abot:FlxAnimate;
    var pupil:FlxAnimate;
    var abotViz:ScriptedFlxSpriteGroup;
	var stereoBG:FunkinSprite;
	var eyeWhites:FunkinSprite;
    var folder:String = 'characters/abot/';
    function onCreate(event:ScriptEvent) 
    {
        super.onCreate(event);

        stereoBG = new FunkinSprite().loadImage(folder + 'stereoBG');
        eyeWhites = new FunkinSprite().makeSolidColor(160, 60);

        pupil = new FlxAnimate(this.x, this.y, Paths.animateAtlas(folder + "systemEyes"));
        pupil.anim.addBySymbol('idle', 'a bot eyes lookin', 24, false);
		pupil.anim.play('idle', true);
		pupil.anim.curFrame = pupil.anim.length - 1;

        abot = new FlxAnimate(this.x, this.y, Paths.animateAtlas(folder + "abotSystem"));
        abot.anim.addBySymbol('idle', 'Abot System', 24, false);
		abot.anim.play('idle', true);
		abot.anim.curFrame = abot.anim.length - 1;

		abotViz = ScriptedFlxSpriteGroup.init('ABotVis', this.x, this.y);
    }

    var VULTURE_THRESHOLD = 0.25 * 2;
    var STATE_DEFAULT = 0;
    var STATE_PRE_RAISE = 1;
    var STATE_RAISE = 2;
    var STATE_READY = 3;
    var STATE_LOWER = 4;
    var currentState:Int = STATE_DEFAULT;
    var MIN_BLINK_DELAY:Int = 3;
	var MAX_BLINK_DELAY:Int = 7;
	var blinkCountdown:Int = MIN_BLINK_DELAY;

    function dance(force:Bool) 
    {
        if (abot != null)
            abot.anim.play('idle', force);

        switch(currentState) 
        {
            case STATE_DEFAULT:
                playAnim(hasDanced ? 'danceRight' : 'danceLeft', force);
				hasDanced = !hasDanced;
            case STATE_PRE_RAISE:
                playAnim('danceLeft', false);
				hasDanced = false;
            case STATE_READY:
                if(blinkCountdown == 0)
                {
                    playAnim('idleKnife', false);
					blinkCountdown = FlxG.random.int(MIN_BLINK_DELAY, MAX_BLINK_DELAY);
                }
                else
                    blinkCountdown--;
            default:
        }
    }

    public override function onSongEvent(scriptEvent:SongEventScriptEvent)
	{
		super.onSongEvent(scriptEvent);
		if (scriptEvent.eventData.eventKind == "FocusCamera")
		{
			var eventProps = scriptEvent.eventData.value;
			switch (Std.parseInt(eventProps.char)) {
				case 0:
					movePupilsRight();
				case 1:
					movePupilsLeft();
				default:
			}
		}

	}

    function onSongStart(event:ScriptEvent)
    {
        abotViz.scriptCall('initAnalyzer', [FlxG.sound.music]);
    }

    //This is dumb but it might work :/
    override function update(elapsed:Float)
	{
		super.update(elapsed);
        
		abot.update(elapsed);
        abotViz.update(elapsed);
        eyeWhites.update(elapsed);
        stereoBG.update(elapsed);
        pupil.update(elapsed);
	}

    public override function draw()
    {
        
        eyeWhites.x = abot.x + 40;
        eyeWhites.y = abot.y + 250;
        eyeWhites.draw();

        pupil.x = abot.x + 60;
        pupil.y = abot.y + 240;
        pupil.draw();

        stereoBG.x = abot.x + 150;
		stereoBG.y = abot.y + 30;
        stereoBG.draw();

		abotViz.x = abot.x + 200;
		abotViz.y = abot.y + 84;
		abotViz.draw();

        abot.x = this.x - 100;
		abot.y = this.globalOffsets[1] + 540; // 764 - 740
		abot.draw();

        super.draw();
    }

    var refershed:Bool = false;
    function onUpdate(event:UpdateScriptEvent)
    {
        super.onUpdate(event);

        transitionState();
    }

    var animationFinished:Bool = false;

	function onAnimationFinished(name:String) 
    {
        super.onAnimationFinished(name);

		switch(currentState) 
        {
            case STATE_RAISE:
				if (name == "raise") {
					animationFinished = true;
					transitionState();
				}
			case STATE_LOWER:
				if (name == "lower") {
					animationFinished = true;
					transitionState();
				}
			default:
        }
    }

    function onAnimationFrame(name:String, frameNumber:Int, frameIndex:Int) 
    {
        super.onAnimationFrame(name, frameNumber, frameIndex);

		switch(currentState) {
			case STATE_PRE_RAISE:
				if (name == "danceLeft" && frameNumber == 13) {
					animationFinished = true;
					transitionState();
				}
			default:
		}
    }

    function transitionState() 
    {
        switch (currentState) 
        {
			case STATE_DEFAULT:
				if (PlayState.instance.health <= VULTURE_THRESHOLD) {
					currentState = STATE_PRE_RAISE;
				} else {
					currentState = STATE_DEFAULT;
				}
			case STATE_PRE_RAISE:
				if (PlayState.instance.health > VULTURE_THRESHOLD) {
					currentState = STATE_DEFAULT;
				} else if (animationFinished) {
					currentState = STATE_RAISE;
					playAnim('raise');
					animationFinished = false;
				}
			case STATE_RAISE:
				if (animationFinished) {
					currentState = STATE_READY;
					animationFinished = false;
				}
			case STATE_READY:
				if (PlayState.instance.health > VULTURE_THRESHOLD) {
					currentState = STATE_LOWER;
					playAnim('lower');
				}
			case STATE_LOWER:
				if (animationFinished) {
					currentState = STATE_DEFAULT;
					animationFinished = false;
				}
			default:
				currentState = STATE_DEFAULT;
		}
    }

    var pupilState:Int = 0;
	var PUPIL_STATE_NORMAL = 0;
	var PUPIL_STATE_LEFT = 1;
    function movePupilsLeft():Void {
		if (pupilState == PUPIL_STATE_LEFT) return;
		trace('Move pupils left');
		pupil.anim.play('idle', true);
		pupil.anim.curFrame = 0;
	}

	function movePupilsRight():Void {
		if (pupilState == PUPIL_STATE_NORMAL) return;
		trace('Move pupils right');
		pupil.anim.play('idle', true);
		pupil.anim.curFrame = 17;
	}
}